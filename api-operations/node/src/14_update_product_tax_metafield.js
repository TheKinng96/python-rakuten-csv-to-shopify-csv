#!/usr/bin/env node
/**
 * Update Shopify product tax metafields
 * 
 * This script updates product.metafields.custom.tax based on tax data from Japanese master files.
 * Tax values are formatted as "8%" or "10%" according to Japanese tax regulations.
 * 
 * Usage:
 *   node 14_update_product_tax_metafield.js                     # Process all products with tax data
 *   node 14_update_product_tax_metafield.js --test-handle <handle>  # Test with single product
 *   node 14_update_product_tax_metafield.js --batch-size 50     # Custom batch size
 *   node 14_update_product_tax_metafield.js --resume-from 1000  # Resume from product 1000
 *   node 14_update_product_tax_metafield.js --dry-run           # Preview changes without updating
 * 
 * Dependencies:
 *   - ../shared/tax_data_to_update.json (generated by Python script)
 *   - config.js (Shopify credentials)
 *   - shopify-client.js (GraphQL client)
 */

import { readFileSync, writeFileSync, existsSync } from 'fs';
import { join } from 'path';
import { shopifyConfig, pathConfig, validateConfig } from './config.js';
import { ShopifyGraphQLClient } from './shopify-client.js';

const GET_PRODUCT_QUERY = `
  query getProduct($handle: String!) {
    productByHandle(handle: $handle) {
      id
      handle
      title
      metafields(namespace: "custom", first: 50) {
        edges {
          node {
            key
            value
            namespace
          }
        }
      }
    }
  }
`;

const UPDATE_PRODUCT_METAFIELD = `
  mutation productUpdate($product: ProductUpdateInput!) {
    productUpdate(product: $product) {
      product {
        id
        handle
        title
        metafields(namespace: "custom", first: 50) {
          edges {
            node {
              key
              value
              namespace
            }
          }
        }
      }
      userErrors {
        field
        message
      }
    }
  }
`;

class TaxMetafieldUpdater {
  constructor() {
    this.client = null;
    this.taxData = new Map();
    this.updateResults = {
      successful: [],
      failed: [],
      notFound: [],
      noChangesNeeded: [],
      skipped: []
    };
    
    this.stats = {
      totalProcessed: 0,
      successfulUpdates: 0,
      failedUpdates: 0,
      notFound: 0,
      noChangesNeeded: 0,
      skipped: 0
    };
    
    this.batchSize = 50;
    this.currentBatch = 0;
    this.resumeFrom = 0;
    this.dryRun = false;
  }

  async initialize() {
    console.log('ðŸ”§ Initializing Shopify GraphQL client...');
    
    if (!validateConfig()) {
      throw new Error('Configuration validation failed');
    }

    this.client = new ShopifyGraphQLClient(false); // Use test store
    await this.client.testConnection();
    console.log('âœ… Connected to Shopify test store');
  }

  loadTaxData() {
    console.log('ðŸ“Š Loading tax data...');
    
    // Try to load from generated JSON file first
    const jsonPath = join(pathConfig.sharedPath, 'tax_data_to_update.json');
    
    if (existsSync(jsonPath)) {
      console.log(`ðŸ“‚ Loading tax data from ${jsonPath}...`);
      const jsonData = JSON.parse(readFileSync(jsonPath, 'utf-8'));
      
      if (jsonData.data && Array.isArray(jsonData.data)) {
        for (const item of jsonData.data) {
          if (item.handle && item.tax_rate) {
            this.taxData.set(item.handle, item.tax_rate);
          }
        }
      } else if (Array.isArray(jsonData)) {
        for (const item of jsonData) {
          if (item.handle && item.tax_rate) {
            this.taxData.set(item.handle, item.tax_rate);
          }
        }
      }
    } else {
      // Fallback: Load directly from CSV files (for testing)
      console.log('ðŸ“‚ Loading tax data directly from CSV files...');
      this.loadTaxDataFromCSV();
    }
    
    console.log(`ðŸ“‹ Loaded tax data for ${this.taxData.size} products`);
    
    // Show tax rate distribution
    const distribution = new Map();
    for (const taxRate of this.taxData.values()) {
      distribution.set(taxRate, (distribution.get(taxRate) || 0) + 1);
    }
    
    console.log('ðŸ“Š Tax rate distribution:');
    for (const [rate, count] of distribution.entries()) {
      console.log(`  ${rate}: ${count} products`);
    }
  }

  loadTaxDataFromCSV() {
    // This method loads tax data directly from CSV files
    // Used as fallback when JSON file is not available
    throw new Error('Tax data JSON file not found. Please run the Python script first to generate tax_data_to_update.json');
  }

  async getProductByHandle(handle) {
    try {
      const result = await this.client.query(GET_PRODUCT_QUERY, { handle });
      return result.productByHandle;
    } catch (error) {
      console.error(`âŒ Error fetching product ${handle}:`, error.message);
      return null;
    }
  }

  getCurrentTaxValue(product) {
    if (!product.metafields || !product.metafields.edges) {
      return null;
    }
    
    const taxMetafield = product.metafields.edges.find(
      edge => edge.node.key === 'tax' && edge.node.namespace === 'custom'
    );
    
    return taxMetafield ? taxMetafield.node.value : null;
  }

  async updateProductTax(product, newTaxValue) {
    const updateInput = {
      id: product.id,
      metafields: [
        {
          namespace: 'custom',
          key: 'tax',
          value: newTaxValue,
          type: 'single_line_text_field'
        }
      ]
    };

    if (this.dryRun) {
      console.log(`ðŸ” DRY RUN: Would update ${product.handle} tax from "${this.getCurrentTaxValue(product)}" to "${newTaxValue}"`);
      return { success: true, dryRun: true };
    }

    try {
      const result = await this.client.mutate(UPDATE_PRODUCT_METAFIELD, { product: updateInput });
      
      if (result.productUpdate.userErrors && result.productUpdate.userErrors.length > 0) {
        const errors = result.productUpdate.userErrors.map(e => `${e.field}: ${e.message}`).join(', ');
        throw new Error(`Shopify API errors: ${errors}`);
      }
      
      return { success: true, result: result.productUpdate.product };
    } catch (error) {
      console.error(`âŒ Error updating product ${product.handle}:`, error.message);
      return { success: false, error: error.message };
    }
  }

  async processProduct(handle, expectedTaxRate) {
    console.log(`ðŸ”„ Processing ${handle}...`);
    
    // Get current product data
    const product = await this.getProductByHandle(handle);
    
    if (!product) {
      console.log(`  âŒ Product not found: ${handle}`);
      this.updateResults.notFound.push({ handle, expectedTaxRate });
      this.stats.notFound++;
      return;
    }
    
    const currentTaxValue = this.getCurrentTaxValue(product);
    
    // Check if update is needed
    if (currentTaxValue === expectedTaxRate) {
      console.log(`  â„¹ï¸  No change needed (already ${expectedTaxRate})`);
      this.updateResults.noChangesNeeded.push({ 
        handle, 
        currentValue: currentTaxValue, 
        expectedValue: expectedTaxRate 
      });
      this.stats.noChangesNeeded++;
      return;
    }
    
    // Update the product
    const updateResult = await this.updateProductTax(product, expectedTaxRate);
    
    if (updateResult.success) {
      if (updateResult.dryRun) {
        console.log(`  ðŸ” DRY RUN: Update prepared`);
        this.updateResults.successful.push({
          handle,
          previousValue: currentTaxValue,
          newValue: expectedTaxRate,
          dryRun: true
        });
      } else {
        console.log(`  âœ… Updated tax from "${currentTaxValue}" to "${expectedTaxRate}"`);
        this.updateResults.successful.push({
          handle,
          previousValue: currentTaxValue,
          newValue: expectedTaxRate,
          updatedProduct: updateResult.result
        });
      }
      this.stats.successfulUpdates++;
    } else {
      console.log(`  âŒ Update failed: ${updateResult.error}`);
      this.updateResults.failed.push({
        handle,
        expectedTaxRate,
        error: updateResult.error
      });
      this.stats.failedUpdates++;
    }
    
    this.stats.totalProcessed++;
  }

  async processBatch(handles) {
    console.log(`\nðŸ“¦ Processing batch ${this.currentBatch + 1} (${handles.length} products)...`);
    
    for (const handle of handles) {
      if (!this.taxData.has(handle)) {
        console.log(`âš ï¸  No tax data for ${handle}, skipping...`);
        this.updateResults.skipped.push({ handle, reason: 'No tax data' });
        this.stats.skipped++;
        continue;
      }
      
      const expectedTaxRate = this.taxData.get(handle);
      await this.processProduct(handle, expectedTaxRate);
      
      // Add small delay between requests to avoid rate limiting
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    this.currentBatch++;
  }

  async processAllProducts() {
    const allHandles = Array.from(this.taxData.keys());
    
    // Apply resume logic
    const startIndex = this.resumeFrom;
    const handlesToProcess = allHandles.slice(startIndex);
    
    console.log(`ðŸš€ Starting processing from product ${startIndex + 1}/${allHandles.length}`);
    console.log(`ðŸ“‹ Will process ${handlesToProcess.length} products in batches of ${this.batchSize}`);
    
    // Process in batches
    for (let i = 0; i < handlesToProcess.length; i += this.batchSize) {
      const batch = handlesToProcess.slice(i, i + this.batchSize);
      await this.processBatch(batch);
      
      // Show progress
      const processed = startIndex + i + batch.length;
      const total = allHandles.length;
      const percentage = ((processed / total) * 100).toFixed(1);
      console.log(`ðŸ“Š Progress: ${processed}/${total} (${percentage}%)`);
      
      // Rate limiting pause between batches
      if (i + this.batchSize < handlesToProcess.length) {
        console.log('â³ Waiting 2 seconds between batches...');
        await new Promise(resolve => setTimeout(resolve, 2000));
      }
    }
  }

  async processTestProduct(handle) {
    console.log(`ðŸ§ª Testing single product: ${handle}`);
    
    if (!this.taxData.has(handle)) {
      console.log(`âŒ No tax data found for handle: ${handle}`);
      return;
    }
    
    const expectedTaxRate = this.taxData.get(handle);
    await this.processProduct(handle, expectedTaxRate);
  }

  generateReport() {
    console.log('\nðŸ“‹ TAX METAFIELD UPDATE SUMMARY');
    console.log('='.repeat(50));
    console.log(`Total processed: ${this.stats.totalProcessed}`);
    console.log(`Successful updates: ${this.stats.successfulUpdates}`);
    console.log(`Failed updates: ${this.stats.failedUpdates}`);
    console.log(`Products not found: ${this.stats.notFound}`);
    console.log(`No changes needed: ${this.stats.noChangesNeeded}`);
    console.log(`Skipped: ${this.stats.skipped}`);
    
    if (this.stats.totalProcessed > 0) {
      const successRate = (this.stats.successfulUpdates / this.stats.totalProcessed * 100).toFixed(1);
      console.log(`Success rate: ${successRate}%`);
    }
    
    // Save detailed report
    const reportPath = join(pathConfig.reportsPath, '14_tax_metafield_update_results.json');
    const reportData = {
      timestamp: new Date().toISOString(),
      settings: {
        batchSize: this.batchSize,
        resumeFrom: this.resumeFrom,
        dryRun: this.dryRun
      },
      stats: this.stats,
      results: this.updateResults
    };
    
    writeFileSync(reportPath, JSON.stringify(reportData, null, 2));
    console.log(`\nðŸ“„ Detailed report saved: ${reportPath}`);
    
    // Show sample results
    if (this.updateResults.successful.length > 0) {
      console.log('\nâœ… Sample successful updates:');
      this.updateResults.successful.slice(0, 5).forEach(item => {
        console.log(`  ${item.handle}: "${item.previousValue}" â†’ "${item.newValue}"`);
      });
    }
    
    if (this.updateResults.failed.length > 0) {
      console.log('\nâŒ Failed updates:');
      this.updateResults.failed.forEach(item => {
        console.log(`  ${item.handle}: ${item.error}`);
      });
    }
  }
}

async function main() {
  const args = process.argv.slice(2);
  
  // Parse command line arguments
  let testHandle = null;
  let batchSize = 50;
  let resumeFrom = 0;
  let dryRun = false;
  
  for (let i = 0; i < args.length; i++) {
    switch (args[i]) {
      case '--test-handle':
        testHandle = args[i + 1];
        i++;
        break;
      case '--batch-size':
        batchSize = parseInt(args[i + 1]);
        i++;
        break;
      case '--resume-from':
        resumeFrom = parseInt(args[i + 1]);
        i++;
        break;
      case '--dry-run':
        dryRun = true;
        break;
    }
  }
  
  console.log('ðŸ·ï¸  TAX METAFIELD UPDATER');
  console.log('='.repeat(50));
  
  if (dryRun) {
    console.log('ðŸ” DRY RUN MODE: No actual updates will be made');
  }
  
  try {
    const updater = new TaxMetafieldUpdater();
    updater.batchSize = batchSize;
    updater.resumeFrom = resumeFrom;
    updater.dryRun = dryRun;
    
    await updater.initialize();
    updater.loadTaxData();
    
    if (updater.taxData.size === 0) {
      console.log('âŒ No tax data loaded. Please check that tax_data_to_update.json exists.');
      return;
    }
    
    if (testHandle) {
      await updater.processTestProduct(testHandle);
    } else {
      await updater.processAllProducts();
    }
    
    updater.generateReport();
    
    console.log('\nâœ… Tax metafield update completed!');
    
  } catch (error) {
    console.error('\nâŒ Error:', error.message);
    process.exit(1);
  }
}

if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}